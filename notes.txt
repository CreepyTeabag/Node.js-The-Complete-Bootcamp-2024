---------- 5 ----------
Node.js is a JavaScript runtime built on google's open-source V8 JavaScript engine.
JS runtime is what runs the JS - the browser or a V8 engine.
So with Node.js we can use JS on a web-server and build fast, highly scalable network applications on backend.

Node.js pros:
- Single-threaded, based on event driven, non-blocking I/O model.
- Perfect for building fast and scalable data-intensive apps;
- Companies like NETFLIX, UBER, PayPal, ebay have started using node in production;
- JavaScript across the entire stack: faster and more efficient development;
- NPM: huge library of open-source packages available for everyone for free;
- Very active developer community.

Use Node.js:
- API with database behind it (preferably NoSQL);
- Data streaming (think YouTube);
- Real-time chat application;
- Server-side web application.

Don't use Node.js:
- Applications with heavy server-side processing (CPU-intensive)
      CPU = central processing unit, центральный процессор

---------- 6 ----------
> node
Opens Node REPL (read-eval-print-loop) and we can write our code in the terminal.

> .exit    or     Ctrl + D
Exits Node REPL.

> Ctrl + L
Clears console

> Tab
Shows all the global variables available in Node

> _
Previous result (i.e. 3 * 8 = 24; _ + 6 = 30)

> String. + Tab
Shows all of the methods available on String. We can do that with any global variable

---------- 7 ----------
> node index.js
Executes index.js

Node.js is built on the concept of modules where all kinds of additional functionality is stored in a module. For example, functionality of reading files is inside of FS (File System) module. We use a module by including it into our code like this:
   const fs = require('fs');

---------- 8 ----------
fs.readFileSync('pathToFile', 'characterEncoding')
Reads file synchronously and returns the data

\n
Goes to a new line

fs.writeFileSync('pathToFile', whatToOutput);
Creates a new file and writes to it

---------- 9 ----------
Synchronous code: each statement is processed one after another, line by line. This code is blocking, because a certain operation can only be executed only after the one before ahs finished.

Asynchronous code is non-blocking, so we offload heavy work to be worked on in the background. And then, once that work is done, a callback function that we registered before is called to handle the result. So the main code continues working while the heavy process is running in the background.

Node.js is single-threaded, which means that whenever users are interacting with the application, the code that is run for each user will be executed all in the same thread at the same place in the computer running the application.
This means that if one user blocks the code in a synchronous way, all the other users will have to wait for that execution to finish. So it's our job as developers to avoid this kind of situation.

So basically Node.js is single-threaded, but it sends all the heavy stuff to the background to make single thread work faster. That's how Node.js implements non-blocking I/O (input/output) model. And that's why Node.js is completely designed around callbacks.

But callbacks !== asynchronous code.

---------- 10 ----------
It is very common in Node.js to have error first, data second in arguments in a callback.